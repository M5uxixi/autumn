<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>线条烟花、文字浮现与图片自动轮播</title>
    
    <style>
        /* ==================== 1. 全局样式和烟花区 ==================== */
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            font-family: Arial, sans-serif;
            color: #fff;
            overflow-x: hidden; /* 防止水平滚动条 */
        }

        /* 烟花全屏容器 */
        #fireworks-section {
            position: relative;
            width: 100%;
            height: 100vh; /* 占满首屏 */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            background-color: #000;
        }

        /* Canvas 用于绘制烟花 */
        #fireworksCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1; /* 烟花在底层 */
        }

        /* ==================== 2. 文字浮现样式 ==================== */
        .fireworks-text {
            position: relative;
            color: #fff;
            font-size: 8vw;
            font-weight: bold;
            font-family: 'Times New Roman', serif; /* 替换为你喜欢的字体 */
            text-align: center;
            z-index: 10; /* 文字浮在烟花之上 */
            /* 初始状态：透明且向上移动 (实现从上到下浮现感) */
            opacity: 0; 
            transform: translateY(-20px); 
            /* 动画：延迟 1.5s 开始，持续 2.5s，向前一步 */
            animation: fadeInDown 2.5s ease-out 1.5s forwards; 
            text-shadow: 0 0 15px #ffcc00, 0 0 30px #ff6600; /* 文字光晕 */
            pointer-events: none; /* 防止文字遮挡 */
        }

        /* 文字浮现（从上往下落）动画关键帧 */
        @keyframes fadeInDown {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }


        /* ==================== 3. 自动轮播图样式 ==================== */
        #content-section {
            background-color: #111; 
            padding: 50px 0;
            text-align: center;
            min-height: 50vh; 
        }

        #content-section h2 {
            font-size: 3em;
            color: #ffcc00;
            margin-bottom: 40px;
        }

        /* 轮播图容器 */
        .carousel-container {
            position: relative;
            max-width: 800px;
            margin: 0 auto;
            overflow: hidden; /* 隐藏超出容器的图片 */
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.7);
        }

        /* 所有图片项的包装器，用于水平移动 */
        .carousel-track {
            display: flex;
            transition: transform 0.8s ease-in-out; /* 切换时的动画效果 */
        }

        /* 单张图片项 */
        .carousel-item {
            min-width: 100%; /* 每张图片占满容器宽度 */
            flex-shrink: 0; /* 防止缩小 */
        }

        .carousel-item img {
            width: 100%;
            height: auto;
            display: block;
        }

    </style>
</head>
<body>
    
    <div id="fireworks-section">
        <canvas id="fireworksCanvas"></canvas>

        <h1 class="fireworks-text">
            海岚宝宝~中秋节快乐！！
        </h1>
    </div>

    <div id="content-section">
        <div class="carousel-container">
            <div class="carousel-track">
                <div class="carousel-item"><img src="autumn/1.jpg"></div>
                <div class="carousel-item"><img src="autumn/2.jpg"></div>
                <div class="carousel-item"><img src="autumn/3.jpg"></div>
                <div class="carousel-item"><img src="autumn/4.jpg"></div>
            </div>
        </div>
    </div>

    <script>
        // ==================== 1. Canvas 烟花线条效果 (JavaScript) ====================
        const canvas = document.getElementById('fireworksCanvas');
        const ctx = canvas.getContext('2d');
        let fireworks = [];
        let particles = [];
        let requestId;

        // 设置canvas大小
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // 烟花主干 (火箭) 类
        class Firework {
            constructor(startX, startY, targetX, targetY) {
                this.x = startX;
                this.y = startY;
                this.startX = startX;
                this.startY = startY;
                this.targetX = targetX;
                this.targetY = targetY;
                this.distanceToTarget = this.calculateDistance(startX, startY, targetX, targetY);
                this.distanceTraveled = 0;
                this.coordinates = []; 
                this.coordinateCount = 3;
                while(this.coordinateCount--) {
                    this.coordinates.push([this.x, this.y]);
                }
                this.angle = Math.atan2(targetY - startY, targetX - startX);
                this.speed = 4; // 火箭上升速度
                this.acceleration = 1.05; // 模拟加速
                this.brightness = Math.random() * 50 + 50; // 亮度
                this.hue = Math.random() * 360; // 颜色
                this.exploded = false;
            }

            calculateDistance(p1x, p1y, p2x, p2y) {
                const xDistance = p1x - p2x;
                const yDistance = p1y - p2y;
                return Math.sqrt(Math.pow(xDistance, 2) + Math.pow(yDistance, 2));
            }

            update() {
                this.coordinates.pop();
                this.coordinates.unshift([this.x, this.y]);

                if (this.exploded) return;

                this.speed *= this.acceleration;
                const vx = Math.cos(this.angle) * this.speed;
                const vy = Math.sin(this.angle) * this.speed;
                this.distanceTraveled = this.calculateDistance(this.startX, this.startY, this.x + vx, this.y + vy);

                // 如果达到目标或超过目标，则爆炸
                if (this.distanceTraveled >= this.distanceToTarget) {
                    this.createParticles();
                    this.exploded = true;
                } else {
                    this.x += vx;
                    this.y += vy;
                }
            }

            draw() {
                ctx.beginPath();
                ctx.moveTo(this.coordinates[this.coordinates.length - 1][0], this.coordinates[this.coordinates.length - 1][1]);
                ctx.lineTo(this.x, this.y);
                ctx.strokeStyle = 'hsl(' + this.hue + ', 100%, ' + this.brightness + '%)';
                ctx.lineWidth = 2; // 线条粗细
                ctx.stroke();
            }

            createParticles() {
                let particleCount = 60; // 爆炸粒子数量
                while (particleCount--) {
                    particles.push(new Particle(this.x, this.y, this.hue));
                }
            }
        }

        // 爆炸粒子 类
        class Particle {
            constructor(x, y, hue) {
                this.x = x;
                this.y = y;
                this.coordinates = [];
                this.coordinateCount = 5; // 粒子尾巴长度
                while(this.coordinateCount--) {
                    this.coordinates.push([this.x, this.y]);
                }
                this.angle = Math.random() * Math.PI * 2;
                this.speed = Math.random() * 7 + 1; // 粒子速度
                this.friction = 0.95; // 摩擦力
                this.gravity = 1; // 重力
                this.hue = hue;
                this.brightness = Math.random() * 60 + 50;
                this.alpha = 1; // 初始透明度
                this.decay = Math.random() * 0.03 + 0.01; // 衰减速度
            }

            update() {
                this.coordinates.pop();
                this.coordinates.unshift([this.x, this.y]);

                this.speed *= this.friction;
                this.x += Math.cos(this.angle) * this.speed;
                this.y += Math.sin(this.angle) * this.speed + this.gravity;
                this.alpha -= this.decay; // 逐渐消失

                // 如果完全透明，标记为过期
                if (this.alpha <= this.decay) {
                    return true; 
                }
                return false;
            }

            draw() {
                ctx.beginPath();
                ctx.moveTo(this.coordinates[this.coordinates.length - 1][0], this.coordinates[this.coordinates.length - 1][1]);
                ctx.lineTo(this.x, this.y);
                ctx.strokeStyle = 'hsla(' + this.hue + ', 100%, ' + this.brightness + '%, ' + this.alpha + ')';
                ctx.lineWidth = 1; // 粒子线条粗细
                ctx.stroke();
            }
        }

        function loop() {
            // 清除画布 (制造拖尾效果)
            ctx.globalCompositeOperation = 'destination-out';
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)'; // 拖尾效果，数值越小拖尾越长
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.globalCompositeOperation = 'lighter'; // 新的绘制叠加

            // 更新和绘制烟花
            let i = fireworks.length;
            while (i--) {
                fireworks[i].draw();
                fireworks[i].update();
                if (fireworks[i].exploded) {
                    fireworks.splice(i, 1);
                }
            }

            // 更新和绘制粒子
            let j = particles.length;
            while (j--) {
                particles[j].draw();
                if (particles[j].update()) { // 如果粒子过期
                    particles.splice(j, 1);
                }
            }

            // 随机发射新的烟花
            if (Math.random() < 0.05) { // 发射频率
                const startX = Math.random() * canvas.width;
                const startY = canvas.height; // 从底部发射
                const targetX = Math.random() * canvas.width;
                const targetY = Math.random() * (canvas.height / 2); // 爆炸点在屏幕上半部分
                fireworks.push(new Firework(startX, startY, targetX, targetY));
            }

            requestId = requestAnimationFrame(loop);
        }

        // 启动烟花动画
        loop();

        // ==================== 2. 图片自动轮播效果 (JavaScript) ====================
        const track = document.querySelector('.carousel-track');
        const items = document.querySelectorAll('.carousel-item');
        const itemCount = items.length;
        let currentIndex = 0;
        const slideInterval = 4000; // 自动切换间隔时间（毫秒），这里是 4 秒

        function moveToNextSlide() {
            // 循环到下一张图片
            currentIndex = (currentIndex + 1) % itemCount;
            updateTrackPosition();
        }

        function updateTrackPosition() {
            // 计算需要水平移动的距离
            const offset = -currentIndex * 100;
            track.style.transform = `translateX(${offset}%)`;
        }

        // 启动自动轮播
        setInterval(moveToNextSlide, slideInterval);

    </script>
</body>

</html>
